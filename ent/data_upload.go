// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"time"

	"github.com/pkg/errors"
	"github.com/spf13/cast"
)

func (c *StockClient) UploadData(ctx context.Context, data [][]string) error {
	var v interface{}
	var err error
	bulk := make([]*StockCreate, len(data))
	for i, row := range data {
		create := c.Create()

		v, err = convert(row[0], "string")
		create.SetMarket(v.(string))

		v, err = convert(row[1], "string")
		create.SetCode(v.(string))

		v, err = convert(row[2], "string")
		create.SetName(v.(string))

		v, err = convert(row[3], "time.Time")
		create.SetDate(v.(time.Time))

		v, err = convert(row[4], "float32")
		create.SetOpen(v.(float32))

		v, err = convert(row[5], "float32")
		create.SetClose(v.(float32))

		v, err = convert(row[6], "float32")
		create.SetHigh(v.(float32))

		v, err = convert(row[7], "float32")
		create.SetLow(v.(float32))

		v, err = convert(row[8], "int32")
		create.SetVolume(v.(int32))

		v, err = convert(row[9], "int32")
		create.SetOutstandingShare(v.(int32))

		v, err = convert(row[10], "float32")
		create.SetTurnover(v.(float32))

		bulk[i] = create
	}
	_, err = c.CreateBulk(bulk...).Save(ctx)
	if err != nil {
		return err
	}
	return nil
}

func (c *UserClient) UploadData(ctx context.Context, data [][]string) error {
	var v interface{}
	var err error
	bulk := make([]*UserCreate, len(data))
	for i, row := range data {
		create := c.Create()

		v, err = convert(row[0], "string")
		create.SetUsername(v.(string))

		v, err = convert(row[1], "string")
		create.SetPassword(v.(string))

		v, err = convert(row[2], "string")
		create.SetEmail(v.(string))

		v, err = convert(row[3], "string")
		create.SetRefreshToken(v.(string))

		v, err = convert(row[4], "time.Time")
		create.SetCreatedAt(v.(time.Time))

		v, err = convert(row[5], "time.Time")
		create.SetUpdatedAt(v.(time.Time))

		bulk[i] = create
	}
	_, err = c.CreateBulk(bulk...).Save(ctx)
	if err != nil {
		return err
	}
	return nil
}

func convert(val interface{}, typ string) (interface{}, error) {
	switch typ {
	case "string", "json.RawMessage":
		return cast.ToStringE(val)
	case "[]byte":
		s, err := cast.ToStringE(val)
		if err != nil {
			return nil, err
		}
		return []byte(s), err
	case "[16]byte":
		var byteArr [16]byte
		s, err := cast.ToStringE(val)
		if err != nil {
			return nil, err
		}
		copy(byteArr[:], s)
		return byteArr, err
	case "time.Time":
		return cast.ToTimeE(val)
	case "bool":
		return cast.ToBoolE(val)
	case "float64":
		return cast.ToFloat64E(val)
	case "float32":
		return cast.ToFloat32E(val)
	case "int64":
		return cast.ToInt64E(val)
	case "int32":
		return cast.ToInt32E(val)
	case "int16":
		return cast.ToInt16E(val)
	case "int8":
		return cast.ToInt8E(val)
	case "int":
		return cast.ToIntE(val)
	case "uint64":
		return cast.ToUint64E(val)
	case "uint32":
		return cast.ToUint32E(val)
	case "uint16":
		return cast.ToUint16E(val)
	case "uint8":
		return cast.ToUint8E(val)
	case "uint":
		return cast.ToUintE(val)
	}
	return nil, errors.Errorf("type '%s' not support", typ)
}
